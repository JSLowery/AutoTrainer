<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, April 23, 2015, 2:45 PM -->
<!-- MuClient version 4.79 -->

<!-- Plugin "AutoTrainer" generated by Plugin Wizard -->

<!--
Version 1 

todo:
allow for  non tiers
cleanup my mess, notes
-->

<muclient>
<plugin
   name="AutoTrainer"
   author="Sonet"
   id="018bb1b2d053af011c0902f9"
   language="Lua"
   purpose="automaticallt trains stats up to cost 3"
   save_state="y"
   date_written="2015-04-23 14:39:13"
   requires="4.79"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Alias is TrainAll

Should train all stats in an order predetermined up to cost 3 or out of trains
Use PrintOrder to see current order
Use SetOrder to set the order, has to be in the form of
	Int Str Luck Wis Dex Con   if you differ it wont work and it will break
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   group="autoTrain"
   match="^Your stats and amount trained are\:$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Base    Race   Tier   Wish   Your                    $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Cost    Mod    Mod    Mod    Cost    Trained    Max  $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              \-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-  \-\-\-\-\-\-\-  \-\-\-\-\-\-\-$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   custom_colour="7"
   group="autoTrain"
   match="^(.+\s*) \:\s* \b(\d?\b)\s* ([-]?\d?\b)\s* ([-]?\d?\b)\s* ([-]?\d?\b)\s*(\b.+?\b)\s*(\b.+?\b)\s*(.+?)(\*)?$"
   omit_from_output="y"
   regexp="y"
   script="trainerStore"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) practice sessions available\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) total stats out of (.*?) maximum\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) training sessions available\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   match="^TrainAll$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>EnableTriggerGroup("autoTrain", true)
--Execute("recal;s")
Execute("train convertall")
Execute("train")

</send>
  </alias>
  <alias
   match="^SetOrder (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4})"
   enabled="y"
   regexp="y"
   script="OrderMatters"
   sequence="100"
  ></alias>
  <alias
   match="^PrintOrder$"
   enabled="y"
   regexp="y"
   script="printOrder"
   sequence="100"
  ></alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
require "tprint"
require "serialize"
value= {}
value.Str= {}
value.Int= {}
value.Wis= {}
value.Con= {}
value.Dex= {}
value.Luck= {}
value.Trains= {}
costCurrent= 0
costMax = 3
curMaxCost = 0
didonce= false
curOrder = {"Int", "Luck", "Wis", "Con", "Dex", "Str"}


--print(test)
function printOrder()
	tprint (curOrder)
	--print (test)
end
function OrderMatters(name, line, wildcards)
	curOrder = {wildcards[1],wildcards[2],wildcards[3],wildcards[4],wildcards[5],wildcards[6]}
	--tprint(wildcards)
	tprint(curOrder)
	SetVariable("test","test ="..serialize.save_simple(curOrder))
   
	--tprint(curOrder)
end
function OnPluginInstall()
	assert (loadstring (GetVariable ("test") or "")) ()
	curOrder = test or  {'Int', 'Luck', 'Wis', 'Con', 'Dex', 'Str'}
end
function trainerStore(name, line, wildcards)
	local str = tostring( wildcards[1])
	if string.find(str, "Hp") or string.find(str, "Moves") or string.find(str, "Mana") then
		if string.find(str, "Moves") then
			EnableTriggerGroup("autoTrain", false)

			for i, p in pairs(curOrder) do
				-- print(p)
				-- tprint(value[p])
				trainerGO(value[p], p)
			end --for
		end --if
		return
	end-- if

	if string.find(str, "Strength") then
		value.Str.Base = tonumber(wildcards[2])
		value.Str.RMod = tonumber(wildcards[3])
		value.Str.TMod = tonumber(wildcards[4])
		value.Str.WMod = tonumber(wildcards[5])
		value.Str.Cost = tonumber(wildcards[6])
		value.Str.Trained = tonumber(wildcards[7])
		value.Str.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Dexterity") then
		value.Dex.Base = tonumber(wildcards[2])
		value.Dex.RMod = tonumber(wildcards[3])
		value.Dex.TMod = tonumber(wildcards[4])
		value.Dex.WMod = tonumber(wildcards[5])
		value.Dex.Cost = tonumber(wildcards[6])
		value.Dex.Trained = tonumber(wildcards[7])
		value.Dex.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Intelligence") then
		value.Int.Base = tonumber(wildcards[2])
		value.Int.RMod = tonumber(wildcards[3])
		value.Int.TMod = tonumber(wildcards[4])
		value.Int.WMod = tonumber(wildcards[5])
		value.Int.Cost = tonumber(wildcards[6])
		value.Int.Trained = tonumber(wildcards[7])
		value.Int.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Wisdom") then
		value.Wis.Base = tonumber(wildcards[2])
		value.Wis.RMod = tonumber(wildcards[3])
		value.Wis.TMod = tonumber(wildcards[4])
		value.Wis.WMod = tonumber(wildcards[5])
		value.Wis.Cost = tonumber(wildcards[6])
		value.Wis.Trained = tonumber(wildcards[7])
		value.Wis.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Constitution") then
		value.Con.Base = tonumber(wildcards[2])
		value.Con.RMod = tonumber(wildcards[3])
		value.Con.TMod = tonumber(wildcards[4])
		value.Con.WMod = tonumber(wildcards[5])
		value.Con.Cost = tonumber(wildcards[6])
		value.Con.Trained = tonumber(wildcards[7])
		value.Con.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Luck") then
		value.Luck.Base = tonumber(wildcards[2])
		value.Luck.RMod = tonumber(wildcards[3])
		value.Luck.TMod = tonumber(wildcards[4])
		value.Luck.WMod = tonumber(wildcards[5])
		value.Luck.Cost = tonumber(wildcards[6])
		value.Luck.Trained = tonumber(wildcards[7])
		value.Luck.Max = tonumber(wildcards[8])
		
	end --if
	res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char") --- We just want the gmcp.char section.
         		luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.

	         assert (loadstring (luastmt or "")) ()
	value.Trains = gmcpdata.worth.trains
	value.Level = tonumber(gmcpdata.status.level)
	if value.Level == 1 and didonce== false then
         			Execute("train convertall")
         			didonce= true
         		end-- if
         		curMaxCost=1
-- value.Con.Base=1
-- value.Con.Cost=1
-- value.Con.Trained = 15
-- value.Int.Trained = 15
-- value.Int.Base = 1
-- value.Int.Cost = 1
--value.Trains = 1750
end
curMaxIndex= {}
curLowestCost= 10
function trainerGO( value1, string)
	if tonumber(value.Trains)==0 then
		--Note("You have no trains")
		return
	end--if
	curMaxIndex = {value.Int.Cost, value.Luck.Cost, value.Wis.Cost, value.Con.Cost, value.Dex.Cost, value.Str.Cost}
	-- print("test "..curMaxCost.." "..curLowestCost)

	for i, value in ipairs(curMaxIndex) do
		-- print(value)
		-- Note(curMaxCost)
		-- Note("curLowestCost "..curLowestCost)
		if tonumber(value) > tonumber(curMaxCost) then
			
			curMaxCost = tonumber(value)
			--Note(curMaxCost)

			--Note(curMaxCost.." is your current max cost")
		end -- if
		if tonumber(value)<tonumber(curLowestCost) then
			curLowestCost= tonumber(value)
			-- Note("curLowestCost "..curLowestCost)
		end--if
		
	end
	if value.Level == 1 then
		if tonumber(value.Int.Trained)<tonumber(value.Int.Max) and tonumber(value.Int.Cost)<=costMax and tonumber(value.Int.Cost)<=curMaxCost then
			
			TrainerTrain(value.Int, "int")
		end--if
	else
		-- print ("v1.Trained "..value1.Trained)
		-- print ("v1.Max "..value1.Max)
		-- print ("v1.Cost "..value1.Cost)
		-- print ("v.Trains "..value.Trains)
		-- print ("cur lowest cost "..curLowestCost)

		if tonumber(value1.Trained)<tonumber(value1.Max) and  tonumber(value1.Cost)<=curLowestCost and tonumber(value.Trains)>=tonumber(value1.Cost) then
		 	TrainerTrain(value1, string)
		-- if tonumber(value.Int.Trained)<tonumber(value.Int.Max) and tonumber(value.Int.Cost)<costMax and tonumber(value.Int.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Int.Cost) then
		-- 	TrainerTrain(value.Int, "int")
		-- elseif tonumber(value.Luck.Trained)<tonumber(value.Luck.Max) and tonumber(value.Luck.Cost)<costMax and tonumber(value.Luck.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Luck.Cost) then
		-- 	TrainerTrain(value.Luck, "luck")
		-- elseif tonumber(value.Wis.Trained)<tonumber(value.Wis.Max) and tonumber(value.Wis.Cost)<costMax and tonumber(value.Wis.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Wis.Cost) then
		-- 	TrainerTrain(value.Wis, "wis")
		-- elseif tonumber(value.Con.Trained)<tonumber(value.Con.Max) and tonumber(value.Con.Cost)<costMax and tonumber(value.Con.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Con.Cost) then
		-- 	TrainerTrain(value.Con, "con")
		-- elseif tonumber(value.Dex.Trained)<tonumber(value.Dex.Max) and tonumber(value.Dex.Cost)<costMax and tonumber(value.Dex.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Dex.Cost) then
		-- 	TrainerTrain(value.Dex, "dex")
		-- elseif tonumber(value.Str.Trained)<tonumber(value.Str.Max) and tonumber(value.Str.Cost)<costMax and tonumber(value.Str.Cost)<=curMaxCost and tonumber(value.Trains)>=tonumber(value.Str.Cost) then
		-- 	TrainerTrain(value.Str, "str")
		else
			-- Note("All Stats are maxed or at cap")
		end --if
	end--if
end

counter= 0
function TrainerTrain(stat, string)
	--Note(string)
	--tprint(stat)
	if tonumber(value.Trains)>= tonumber(stat.Cost)  then
			
			counter = counter + 1
			--Note("counter: "..counter.. "trained: ".. string)
			value.Trains= value.Trains-stat.Cost
			stat.Trained = stat.Trained+1
			
	else
			--Note("Not Enough Trains")

			return
	end --if
	checkLimit(stat)
		if tonumber(stat.Trained)>=tonumber(stat.Max) or tonumber(stat.Cost)>=costMax or tonumber(stat.Cost)>curMaxCost or tonumber(value.Trains)<tonumber(stat.Cost) then
				--Note(curMaxCost.." is curMaxCost ")
				Execute ("train "..counter.." "..string )
				counter= 0
		end-- if
		
		--Note(value.Trains.." Trains Left")
		if tonumber(value.Trains)>=tonumber(curLowestCost) then
			--Note("again")
			trainerGO(stat, string)
			
			
		end --if
		
	
end
function checkLimit(stat)
	if tonumber(stat.Trained)>60 then
		if tonumber(stat.Trained)>=71 and tonumber(stat.Trained)<=90 then
			if tonumber(stat.Base)==1 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=91 and tonumber(stat.Trained)<=130 then
			if tonumber(stat.Base)==2 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			--Note (testMax.. " is TestMax ".. stat.Cost.." is Cost")
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=131 and tonumber(stat.Trained)<=170 then
			if tonumber(stat.Base)==3 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=171 and stat.Trained<=200 then
			if tonumber(stat.Base)==4 then
				stat.Base = stat.Base +2
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		
		elseif tonumber(stat.Trained)>=201 and stat.Trained<=224 then
			if tonumber(stat.Base)==6 then
				stat.Base = stat.Base +3
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=225 and stat.Trained<=250 then
			if tonumber(stat.Base)==9 then
				stat.Base = stat.Base +2
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=251 and stat.Trained<=275 then
			if tonumber(stat.Base)==11 then
				stat.Base = stat.Base +3
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		end --if
	end--if
end



]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="AutoTrainer:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
