<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, April 23, 2015, 2:45 PM -->
<!-- MuClient version 4.79 -->

<!-- Plugin "AutoTrainer" generated by Plugin Wizard -->

<!--
Version 1 

todo:
allow for  non tiers
cleanup my mess, notes
-->

<muclient>
<plugin
   name="AutoTrainer"
   author="Sonet"
   id="018bb1b2d053af011c0902f9"
   language="Lua"
   purpose="automaticallt trains stats up to cost 3"
   save_state="y"
   date_written="2015-04-23 14:39:13"
   requires="4.79"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Alias is TrainAll

Should train all stats in an order predetermined up to cost 3 or out of trains
Use PrintOrder to see current order
Use SetOrder to set the order, has to be in the form of
	Int Str Luck Wis Dex Con   if you differ it wont work and it will break
Use PrintMaxNum to display your current maximum
Use SetMaxNum <number> to set your current maximum
]]>
</description>

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   group="autoTrain"
   match="^Your stats and amount trained are\:$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Base    Race   Tier   Wish   Your                    $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Base    Race   Wish   Your                    $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Cost    Mod    Mod    Mod    Cost    Trained    Max  $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              Cost    Mod    Mod    Cost    Trained    Max  $"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              \-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-  \-\-\-\-\-\-\-  \-\-\-\-\-\-\-$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^              \-\-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\- \-\-\-\-\-\-  \-\-\-\-\-\-\-  \-\-\-\-\-\-\-$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   custom_colour="7"
   group="autoTrain"
   match="^(\w+)\s*\:\s* \b(\d?\b)\s* ([-]?\d?\b)\s* ([-]?\d?\b)?\s* ([-]?\d?\b)\s*(\b.+?\b)\s*(\b.+?\b)\s*(.+?)(\*)?$"
   omit_from_output="y"
   regexp="y"
   script="trainerStore"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   custom_colour="7"
   group="autoTrain"
   match="^(\w+)\s*\:\s* \b(\d?\b)\s* ([-]?\d?\b)\s* ([-]?\d?\b)\s*(\b.+?\b)\s*(\b.+?\b)\s*(.+?)(\*)?$"
   omit_from_output="y"
   regexp="y"
   script="trainerStore"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) practice sessions available\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) total stats out of (.*?) maximum\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
  <trigger
   group="autoTrain"
   match="^You have (.*?) training sessions available\.$"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   match="^TrainAll$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>EnableTriggerGroup("autoTrain", true)
--Execute("recal;s")
Execute("train convertall")
Execute("train")

</send>
  </alias>
  <alias
   match="^SetOrder (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4}) (.{1,4})"
   enabled="y"
   regexp="y"
   script="OrderMatters"
   sequence="100"
  ></alias>
   <alias
   match="^SetMaxNum (\d+)"
   enabled="y"
   regexp="y"
   script="setMaxNum"
   sequence="100"
  ></alias>
   <alias
   match="^PrintMaxNum"
   enabled="y"
   regexp="y"
   script="PrintMaxNum"
   sequence="100"
  ></alias>
  <alias
   match="^PrintOrder$"
   enabled="y"
   regexp="y"
   script="printOrder"
   sequence="100"
  ></alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
require "tprint"
require "serialize"
value= {}
value.Str= {}
value.Int= {}
value.Wis= {}
value.Con= {}
value.Dex= {}
value.Luck= {}
value.Trains= {}
costCurrent= 0
costMax = 3
curMaxCost = 0
didonce= false
curOrder = {"Int", "Luck", "Wis", "Con", "Dex", "Str"}
MaxNum = 3


function PrintMaxNum()
    print(string.format("Your current train max number is %s", costMax))
end

function setMaxNum(name, line, wildcards)
    local max = tonumber(wildcards[1])
    if max > 0 then
        costMax = tonumber(max)
        SetVariable("maxNum","maxNum ="..serialize.save_simple(costMax))
        print(string.format("You have set your Max to %s", costMax))
    else
        print("Max number cannot be negative")
    end
end

function printOrder()
	tprint (curOrder)

end
function OrderMatters(name, line, wildcards)
	curOrder = {wildcards[1],wildcards[2],wildcards[3],wildcards[4],wildcards[5],wildcards[6]}

	SetVariable("test","test ="..serialize.save_simple(curOrder))

end
function OnPluginInstall()
	assert (loadstring (GetVariable ("test") or "")) ()
	curOrder = test or  {'Int', 'Luck', 'Wis', 'Con', 'Dex', 'Str'}
    assert(loadstring(GetVariable("maxNum") or "")) ()
    costMax = maxNum or 3
end
function check_Lowest_Max_Cost()
	curLowestCost= costMax
	curMaxCost= 0
	curMaxIndex = {value.Int, value.Luck, value.Wis, value.Con, value.Dex, value.Str}
	for i, value in ipairs(curMaxIndex) do

		if tonumber(value.Cost) > tonumber(curMaxCost) then
			
			curMaxCost = tonumber(value.Cost)

			if value.Cost > costMax then curMaxCost = costMax end--if
		end -- if
		if tonumber(value.Cost)<tonumber(curLowestCost) and value.Trained ~= value.Max then
			curLowestCost= tonumber(value.Cost)
		end--if
	end
end
function trainerStore(name, line, wildcards)
	local counter = 0
	local str = tostring( wildcards[1])
	if string.find(str, "Hp") or string.find(str, "Moves") or string.find(str, "Mana") then
		if string.find(str, "Moves") then
			EnableTriggerGroup("autoTrain", false)
			check_Lowest_Max_Cost()
			while tonumber(value.Trains) >= tonumber(curLowestCost) and curLowestCost < costMax do-- this is a test case mother fucker also stop programming while drunk
				check_Lowest_Max_Cost()
				for i, p in pairs(curOrder) do
					check_Lowest_Max_Cost()
					if (value[p].Cost ~= costMax) then 
						trainerGO(value[p], p)
					end--if
				end --for
				counter = counter +1
				if counter> costMax then return end
			end
		end --if
		return
	end-- if

	if string.find(str, "Strength") then
		value.Str.Base = tonumber(wildcards[2])
		value.Str.RMod = tonumber(wildcards[3])
		value.Str.TMod = tonumber(wildcards[4])
		value.Str.WMod = tonumber(wildcards[5])
		value.Str.Cost = tonumber(wildcards[6])
		value.Str.Trained = tonumber(wildcards[7])
		value.Str.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Dexterity") then
		value.Dex.Base = tonumber(wildcards[2])
		value.Dex.RMod = tonumber(wildcards[3])
		value.Dex.TMod = tonumber(wildcards[4])
		value.Dex.WMod = tonumber(wildcards[5])
		value.Dex.Cost = tonumber(wildcards[6])
		value.Dex.Trained = tonumber(wildcards[7])
		value.Dex.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Intelligence") then
		value.Int.Base = tonumber(wildcards[2])
		value.Int.RMod = tonumber(wildcards[3])
		value.Int.TMod = tonumber(wildcards[4])
		value.Int.WMod = tonumber(wildcards[5])
		value.Int.Cost = tonumber(wildcards[6])
		value.Int.Trained = tonumber(wildcards[7])
		value.Int.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Wisdom") then
		value.Wis.Base = tonumber(wildcards[2])
		value.Wis.RMod = tonumber(wildcards[3])
		value.Wis.TMod = tonumber(wildcards[4])
		value.Wis.WMod = tonumber(wildcards[5])
		value.Wis.Cost = tonumber(wildcards[6])
		value.Wis.Trained = tonumber(wildcards[7])
		value.Wis.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Constitution") then
		value.Con.Base = tonumber(wildcards[2])
		value.Con.RMod = tonumber(wildcards[3])
		value.Con.TMod = tonumber(wildcards[4])
		value.Con.WMod = tonumber(wildcards[5])
		value.Con.Cost = tonumber(wildcards[6])
		value.Con.Trained = tonumber(wildcards[7])
		value.Con.Max = tonumber(wildcards[8])
		
	end --if
	if string.find(str, "Luck") then
		value.Luck.Base = tonumber(wildcards[2])
		value.Luck.RMod = tonumber(wildcards[3])
		value.Luck.TMod = tonumber(wildcards[4])
		value.Luck.WMod = tonumber(wildcards[5])
		value.Luck.Cost = tonumber(wildcards[6])
		value.Luck.Trained = tonumber(wildcards[7])
		value.Luck.Max = tonumber(wildcards[8])
		
	end --if
	res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char") --- We just want the gmcp.char section.
         		luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.

	         assert (loadstring (luastmt or "")) ()
	value.Trains = gmcpdata.worth.trains
	value.Level = tonumber(gmcpdata.status.level)
	if value.Level == 1 and didonce== false then
         			Execute("train convertall")
         			didonce= true
         		end-- if
         		curMaxCost=1
-- value.Con.Base=1
-- value.Con.Cost=1
-- value.Con.Trained = 15
-- value.Int.Trained = 15
-- value.Int.Base = 1
-- value.Int.Cost = 1
-- value.Trains = 100
end
curMaxIndex= {}
curLowestCost= 10
function trainerGO( value1, string)
	local count = 0
	if tonumber(value.Trains)==0 then
		return
	end--if
		if tonumber(value1.Trained)<tonumber(value1.Max) and  tonumber(value1.Cost)<=curLowestCost and tonumber(value.Trains)>=tonumber(value1.Cost) then
		else

		end --if
end

counter= 0
function TrainerTrain(stat, string)
	if tonumber(value.Trains)>= tonumber(stat.Cost)  then
			
			counter = counter + 1
			value.Trains= value.Trains-stat.Cost
			stat.Trained = stat.Trained+1
			
	else

			return
	end --if
	checkLimit(stat)
		if tonumber(stat.Trained)>=tonumber(stat.Max) or tonumber(stat.Cost)>=costMax or tonumber(stat.Cost)>curLowestCost or tonumber(value.Trains)<tonumber(stat.Cost) then
				Execute ("train "..counter.." "..string )
				counter= 0
		end-- if
		if tonumber(value.Trains)>=tonumber(curLowestCost) then
			trainerGO(stat, string)
			
			
		end --if
		
	
end
function checkLimit(stat)
	if tonumber(stat.Trained)>=60 then
        if stat.RMod > 0 then
            stat.Cost = stat.Cost + stat.RMod
        end
		if tonumber(stat.Trained)>=71 and tonumber(stat.Trained)<=90 then
			if tonumber(stat.Base)==1 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=91 and tonumber(stat.Trained)<=130 then
			if tonumber(stat.Base)==2 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=131 and tonumber(stat.Trained)<=170 then
			if tonumber(stat.Base)==3 then
				stat.Base = stat.Base +1
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=171 and stat.Trained<=200 then
			if tonumber(stat.Base)==4 then
				stat.Base = stat.Base +2
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		
		elseif tonumber(stat.Trained)>=201 and stat.Trained<=224 then
			if tonumber(stat.Base)==6 then
				stat.Base = stat.Base +3
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=225 and stat.Trained<=250 then
			if tonumber(stat.Base)==9 then
				stat.Base = stat.Base +2
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		elseif tonumber(stat.Trained)>=251 and stat.Trained<=275 then
			if tonumber(stat.Base)==11 then
				stat.Base = stat.Base +3
			end --if
			local testMax= stat.Base+ stat.TMod+ stat.RMod+ stat.WMod
			if testMax> stat.Cost then
				stat.Cost = testMax
			end--if
		end --if
	end--if
end



]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="AutoTrainer help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
